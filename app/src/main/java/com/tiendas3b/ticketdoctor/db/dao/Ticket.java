package com.tiendas3b.ticketdoctor.db.dao;

import java.util.List;
import com.tiendas3b.ticketdoctor.db.dao.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
/**
 * Entity mapped to table "TICKET".
 */
public class Ticket {

    private Long id;
    /** Not-null value. */
    private String observations;
    private Boolean remoteSolution;
    private java.util.Date openingDate;
    private java.util.Date updateDate;
    private java.util.Date solutionDate;
    private java.util.Date closingDate;
    private Integer solutionId;
    private String file;
    private String caption;
    private Integer openDays;
    private String lapsed;
    private long applicantId;
    private long keyboarderId;
    private Long waitingForUserId;
    private Long waitingForProviderId;
    private Long technicianId;
    private long categoryId;
    private long projectStatusId;
    private Long typeId;
    private long statusId;
    private long symptomId;
    private Long diagnosticId;
    private Long causeId;
    private long branchId;
    private Long standardSolutionId;
    private Long possibleOriginId;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient TicketDao myDao;

    private User applicant;
    private Long applicant__resolvedKey;

    private User keyboarder;
    private Long keyboarder__resolvedKey;

    private User waitingForUser;
    private Long waitingForUser__resolvedKey;

    private Provider waitingForProvider;
    private Long waitingForProvider__resolvedKey;

    private User technician;
    private Long technician__resolvedKey;

    private Category category;
    private Long category__resolvedKey;

    private ProjectStatus projectStatus;
    private Long projectStatus__resolvedKey;

    private Type type;
    private Long type__resolvedKey;

    private TicketStatus status;
    private Long status__resolvedKey;

    private TypeSymptom typeSymptom;
    private Long typeSymptom__resolvedKey;

    private SymptomDiagnostic symptomDiagnostic;
    private Long symptomDiagnostic__resolvedKey;

    private ImpCause cause;
    private Long cause__resolvedKey;

    private Branch branch;
    private Long branch__resolvedKey;

    private StandardSolution standardSolution;
    private Long standardSolution__resolvedKey;

    private PossibleOrigin possibleOrigin;
    private Long possibleOrigin__resolvedKey;

    private List<Action> actions;

    public Ticket() {
    }

    public Ticket(Long id) {
        this.id = id;
    }

    public Ticket(Long id, String observations, Boolean remoteSolution, java.util.Date openingDate, java.util.Date updateDate, java.util.Date solutionDate, java.util.Date closingDate, Integer solutionId, String file, String caption, Integer openDays, String lapsed, long applicantId, long keyboarderId, Long waitingForUserId, Long waitingForProviderId, Long technicianId, long categoryId, long projectStatusId, Long typeId, long statusId, long symptomId, Long diagnosticId, Long causeId, long branchId, Long standardSolutionId, Long possibleOriginId) {
        this.id = id;
        this.observations = observations;
        this.remoteSolution = remoteSolution;
        this.openingDate = openingDate;
        this.updateDate = updateDate;
        this.solutionDate = solutionDate;
        this.closingDate = closingDate;
        this.solutionId = solutionId;
        this.file = file;
        this.caption = caption;
        this.openDays = openDays;
        this.lapsed = lapsed;
        this.applicantId = applicantId;
        this.keyboarderId = keyboarderId;
        this.waitingForUserId = waitingForUserId;
        this.waitingForProviderId = waitingForProviderId;
        this.technicianId = technicianId;
        this.categoryId = categoryId;
        this.projectStatusId = projectStatusId;
        this.typeId = typeId;
        this.statusId = statusId;
        this.symptomId = symptomId;
        this.diagnosticId = diagnosticId;
        this.causeId = causeId;
        this.branchId = branchId;
        this.standardSolutionId = standardSolutionId;
        this.possibleOriginId = possibleOriginId;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getTicketDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    /** Not-null value. */
    public String getObservations() {
        return observations;
    }

    /** Not-null value; ensure this value is available before it is saved to the database. */
    public void setObservations(String observations) {
        this.observations = observations;
    }

    public Boolean getRemoteSolution() {
        return remoteSolution;
    }

    public void setRemoteSolution(Boolean remoteSolution) {
        this.remoteSolution = remoteSolution;
    }

    public java.util.Date getOpeningDate() {
        return openingDate;
    }

    public void setOpeningDate(java.util.Date openingDate) {
        this.openingDate = openingDate;
    }

    public java.util.Date getUpdateDate() {
        return updateDate;
    }

    public void setUpdateDate(java.util.Date updateDate) {
        this.updateDate = updateDate;
    }

    public java.util.Date getSolutionDate() {
        return solutionDate;
    }

    public void setSolutionDate(java.util.Date solutionDate) {
        this.solutionDate = solutionDate;
    }

    public java.util.Date getClosingDate() {
        return closingDate;
    }

    public void setClosingDate(java.util.Date closingDate) {
        this.closingDate = closingDate;
    }

    public Integer getSolutionId() {
        return solutionId;
    }

    public void setSolutionId(Integer solutionId) {
        this.solutionId = solutionId;
    }

    public String getFile() {
        return file;
    }

    public void setFile(String file) {
        this.file = file;
    }

    public String getCaption() {
        return caption;
    }

    public void setCaption(String caption) {
        this.caption = caption;
    }

    public Integer getOpenDays() {
        return openDays;
    }

    public void setOpenDays(Integer openDays) {
        this.openDays = openDays;
    }

    public String getLapsed() {
        return lapsed;
    }

    public void setLapsed(String lapsed) {
        this.lapsed = lapsed;
    }

    public long getApplicantId() {
        return applicantId;
    }

    public void setApplicantId(long applicantId) {
        this.applicantId = applicantId;
    }

    public long getKeyboarderId() {
        return keyboarderId;
    }

    public void setKeyboarderId(long keyboarderId) {
        this.keyboarderId = keyboarderId;
    }

    public Long getWaitingForUserId() {
        return waitingForUserId;
    }

    public void setWaitingForUserId(Long waitingForUserId) {
        this.waitingForUserId = waitingForUserId;
    }

    public Long getWaitingForProviderId() {
        return waitingForProviderId;
    }

    public void setWaitingForProviderId(Long waitingForProviderId) {
        this.waitingForProviderId = waitingForProviderId;
    }

    public Long getTechnicianId() {
        return technicianId;
    }

    public void setTechnicianId(Long technicianId) {
        this.technicianId = technicianId;
    }

    public long getCategoryId() {
        return categoryId;
    }

    public void setCategoryId(long categoryId) {
        this.categoryId = categoryId;
    }

    public long getProjectStatusId() {
        return projectStatusId;
    }

    public void setProjectStatusId(long projectStatusId) {
        this.projectStatusId = projectStatusId;
    }

    public Long getTypeId() {
        return typeId;
    }

    public void setTypeId(Long typeId) {
        this.typeId = typeId;
    }

    public long getStatusId() {
        return statusId;
    }

    public void setStatusId(long statusId) {
        this.statusId = statusId;
    }

    public long getSymptomId() {
        return symptomId;
    }

    public void setSymptomId(long symptomId) {
        this.symptomId = symptomId;
    }

    public Long getDiagnosticId() {
        return diagnosticId;
    }

    public void setDiagnosticId(Long diagnosticId) {
        this.diagnosticId = diagnosticId;
    }

    public Long getCauseId() {
        return causeId;
    }

    public void setCauseId(Long causeId) {
        this.causeId = causeId;
    }

    public long getBranchId() {
        return branchId;
    }

    public void setBranchId(long branchId) {
        this.branchId = branchId;
    }

    public Long getStandardSolutionId() {
        return standardSolutionId;
    }

    public void setStandardSolutionId(Long standardSolutionId) {
        this.standardSolutionId = standardSolutionId;
    }

    public Long getPossibleOriginId() {
        return possibleOriginId;
    }

    public void setPossibleOriginId(Long possibleOriginId) {
        this.possibleOriginId = possibleOriginId;
    }

    /** To-one relationship, resolved on first access. */
    public User getApplicant() {
        long __key = this.applicantId;
        if (applicant__resolvedKey == null || !applicant__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            UserDao targetDao = daoSession.getUserDao();
            User applicantNew = targetDao.load(__key);
            synchronized (this) {
                applicant = applicantNew;
            	applicant__resolvedKey = __key;
            }
        }
        return applicant;
    }

    public void setApplicant(User applicant) {
        if (applicant == null) {
            throw new DaoException("To-one property 'applicantId' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.applicant = applicant;
            applicantId = applicant.getId();
            applicant__resolvedKey = applicantId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public User getKeyboarder() {
        long __key = this.keyboarderId;
        if (keyboarder__resolvedKey == null || !keyboarder__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            UserDao targetDao = daoSession.getUserDao();
            User keyboarderNew = targetDao.load(__key);
            synchronized (this) {
                keyboarder = keyboarderNew;
            	keyboarder__resolvedKey = __key;
            }
        }
        return keyboarder;
    }

    public void setKeyboarder(User keyboarder) {
        if (keyboarder == null) {
            throw new DaoException("To-one property 'keyboarderId' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.keyboarder = keyboarder;
            keyboarderId = keyboarder.getId();
            keyboarder__resolvedKey = keyboarderId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public User getWaitingForUser() {
        Long __key = this.waitingForUserId;
        if (waitingForUser__resolvedKey == null || !waitingForUser__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            UserDao targetDao = daoSession.getUserDao();
            User waitingForUserNew = targetDao.load(__key);
            synchronized (this) {
                waitingForUser = waitingForUserNew;
            	waitingForUser__resolvedKey = __key;
            }
        }
        return waitingForUser;
    }

    public void setWaitingForUser(User waitingForUser) {
        synchronized (this) {
            this.waitingForUser = waitingForUser;
            waitingForUserId = waitingForUser == null ? null : waitingForUser.getId();
            waitingForUser__resolvedKey = waitingForUserId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public Provider getWaitingForProvider() {
        Long __key = this.waitingForProviderId;
        if (waitingForProvider__resolvedKey == null || !waitingForProvider__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            ProviderDao targetDao = daoSession.getProviderDao();
            Provider waitingForProviderNew = targetDao.load(__key);
            synchronized (this) {
                waitingForProvider = waitingForProviderNew;
            	waitingForProvider__resolvedKey = __key;
            }
        }
        return waitingForProvider;
    }

    public void setWaitingForProvider(Provider waitingForProvider) {
        synchronized (this) {
            this.waitingForProvider = waitingForProvider;
            waitingForProviderId = waitingForProvider == null ? null : waitingForProvider.getId();
            waitingForProvider__resolvedKey = waitingForProviderId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public User getTechnician() {
        Long __key = this.technicianId;
        if (technician__resolvedKey == null || !technician__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            UserDao targetDao = daoSession.getUserDao();
            User technicianNew = targetDao.load(__key);
            synchronized (this) {
                technician = technicianNew;
            	technician__resolvedKey = __key;
            }
        }
        return technician;
    }

    public void setTechnician(User technician) {
        synchronized (this) {
            this.technician = technician;
            technicianId = technician == null ? null : technician.getId();
            technician__resolvedKey = technicianId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public Category getCategory() {
        long __key = this.categoryId;
        if (category__resolvedKey == null || !category__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            CategoryDao targetDao = daoSession.getCategoryDao();
            Category categoryNew = targetDao.load(__key);
            synchronized (this) {
                category = categoryNew;
            	category__resolvedKey = __key;
            }
        }
        return category;
    }

    public void setCategory(Category category) {
        if (category == null) {
            throw new DaoException("To-one property 'categoryId' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.category = category;
            categoryId = category.getId();
            category__resolvedKey = categoryId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public ProjectStatus getProjectStatus() {
        long __key = this.projectStatusId;
        if (projectStatus__resolvedKey == null || !projectStatus__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            ProjectStatusDao targetDao = daoSession.getProjectStatusDao();
            ProjectStatus projectStatusNew = targetDao.load(__key);
            synchronized (this) {
                projectStatus = projectStatusNew;
            	projectStatus__resolvedKey = __key;
            }
        }
        return projectStatus;
    }

    public void setProjectStatus(ProjectStatus projectStatus) {
        if (projectStatus == null) {
            throw new DaoException("To-one property 'projectStatusId' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.projectStatus = projectStatus;
            projectStatusId = projectStatus.getId();
            projectStatus__resolvedKey = projectStatusId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public Type getType() {
        Long __key = this.typeId;
        if (type__resolvedKey == null || !type__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            TypeDao targetDao = daoSession.getTypeDao();
            Type typeNew = targetDao.load(__key);
            synchronized (this) {
                type = typeNew;
            	type__resolvedKey = __key;
            }
        }
        return type;
    }

    public void setType(Type type) {
        synchronized (this) {
            this.type = type;
            typeId = type == null ? null : type.getId();
            type__resolvedKey = typeId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public TicketStatus getStatus() {
        long __key = this.statusId;
        if (status__resolvedKey == null || !status__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            TicketStatusDao targetDao = daoSession.getTicketStatusDao();
            TicketStatus statusNew = targetDao.load(__key);
            synchronized (this) {
                status = statusNew;
            	status__resolvedKey = __key;
            }
        }
        return status;
    }

    public void setStatus(TicketStatus status) {
        if (status == null) {
            throw new DaoException("To-one property 'statusId' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.status = status;
            statusId = status.getId();
            status__resolvedKey = statusId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public TypeSymptom getTypeSymptom() {
        long __key = this.symptomId;
        if (typeSymptom__resolvedKey == null || !typeSymptom__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            TypeSymptomDao targetDao = daoSession.getTypeSymptomDao();
            TypeSymptom typeSymptomNew = targetDao.load(__key);
            synchronized (this) {
                typeSymptom = typeSymptomNew;
            	typeSymptom__resolvedKey = __key;
            }
        }
        return typeSymptom;
    }

    public void setTypeSymptom(TypeSymptom typeSymptom) {
        if (typeSymptom == null) {
            throw new DaoException("To-one property 'symptomId' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.typeSymptom = typeSymptom;
            symptomId = typeSymptom.getId();
            typeSymptom__resolvedKey = symptomId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public SymptomDiagnostic getSymptomDiagnostic() {
        Long __key = this.diagnosticId;
        if (symptomDiagnostic__resolvedKey == null || !symptomDiagnostic__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            SymptomDiagnosticDao targetDao = daoSession.getSymptomDiagnosticDao();
            SymptomDiagnostic symptomDiagnosticNew = targetDao.load(__key);
            synchronized (this) {
                symptomDiagnostic = symptomDiagnosticNew;
            	symptomDiagnostic__resolvedKey = __key;
            }
        }
        return symptomDiagnostic;
    }

    public void setSymptomDiagnostic(SymptomDiagnostic symptomDiagnostic) {
        synchronized (this) {
            this.symptomDiagnostic = symptomDiagnostic;
            diagnosticId = symptomDiagnostic == null ? null : symptomDiagnostic.getId();
            symptomDiagnostic__resolvedKey = diagnosticId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public ImpCause getCause() {
        Long __key = this.causeId;
        if (cause__resolvedKey == null || !cause__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            ImpCauseDao targetDao = daoSession.getImpCauseDao();
            ImpCause causeNew = targetDao.load(__key);
            synchronized (this) {
                cause = causeNew;
            	cause__resolvedKey = __key;
            }
        }
        return cause;
    }

    public void setCause(ImpCause cause) {
        synchronized (this) {
            this.cause = cause;
            causeId = cause == null ? null : cause.getId();
            cause__resolvedKey = causeId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public Branch getBranch() {
        long __key = this.branchId;
        if (branch__resolvedKey == null || !branch__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            BranchDao targetDao = daoSession.getBranchDao();
            Branch branchNew = targetDao.load(__key);
            synchronized (this) {
                branch = branchNew;
            	branch__resolvedKey = __key;
            }
        }
        return branch;
    }

    public void setBranch(Branch branch) {
        if (branch == null) {
            throw new DaoException("To-one property 'branchId' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.branch = branch;
            branchId = branch.getId();
            branch__resolvedKey = branchId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public StandardSolution getStandardSolution() {
        Long __key = this.standardSolutionId;
        if (standardSolution__resolvedKey == null || !standardSolution__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            StandardSolutionDao targetDao = daoSession.getStandardSolutionDao();
            StandardSolution standardSolutionNew = targetDao.load(__key);
            synchronized (this) {
                standardSolution = standardSolutionNew;
            	standardSolution__resolvedKey = __key;
            }
        }
        return standardSolution;
    }

    public void setStandardSolution(StandardSolution standardSolution) {
        synchronized (this) {
            this.standardSolution = standardSolution;
            standardSolutionId = standardSolution == null ? null : standardSolution.getId();
            standardSolution__resolvedKey = standardSolutionId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public PossibleOrigin getPossibleOrigin() {
        Long __key = this.possibleOriginId;
        if (possibleOrigin__resolvedKey == null || !possibleOrigin__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            PossibleOriginDao targetDao = daoSession.getPossibleOriginDao();
            PossibleOrigin possibleOriginNew = targetDao.load(__key);
            synchronized (this) {
                possibleOrigin = possibleOriginNew;
            	possibleOrigin__resolvedKey = __key;
            }
        }
        return possibleOrigin;
    }

    public void setPossibleOrigin(PossibleOrigin possibleOrigin) {
        synchronized (this) {
            this.possibleOrigin = possibleOrigin;
            possibleOriginId = possibleOrigin == null ? null : possibleOrigin.getId();
            possibleOrigin__resolvedKey = possibleOriginId;
        }
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<Action> getActions() {
        if (actions == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            ActionDao targetDao = daoSession.getActionDao();
            List<Action> actionsNew = targetDao._queryTicket_Actions(id);
            synchronized (this) {
                if(actions == null) {
                    actions = actionsNew;
                }
            }
        }
        return actions;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetActions() {
        actions = null;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

}
